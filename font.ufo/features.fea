# # Documentation
#
# This file's syntax and semantics is documented at:
#
# http://adobe-type-tools.github.io/afdko/OpenTypeFeatureFileSpecification.html
#
# The asdfo library then compiles it to an OTF font, the glyph substitution
# part creates GSUB tables in the OTF font. The general documentation how the
# Glyph Substitution table (GSUB) works is described at:
#
# https://docs.microsoft.com/en-us/typography/opentype/spec/gsub
#
# Roughly speaking, the GSUB mechanism is composed of substitution lookups
# (LookupList) tables, each is one of 7 kinds:
# * GSUB LookupType 1: single (a -> x)
# * GSUB LookupType 2: multiple (a -> x y z)
# * GSUB LookupType 3: alternate (a -> x, where x is one of several glyphs)
# * GSUB LookupType 4: ligature (a b c -> x)
# * GSUB LookupType 5: context (a b' d -> x)
# * GSUB LookupType 6: chaining context (chain multiple "context" substitutions)
# * GSUB LookupType 7: extension (use 32-bit offsets instead of 16-bit)
# * GSUB LookupType 8: reverse chaining context (applied from right to left)
#
# The `features.fea` file compiles into these tables, but allows to specify the
# rules in a higher level / simpler language.
#
# # Single
#
# substitute <glyph> by <glyph>;            # format A
# substitute <glyphclass> by <glyph>;       # format B
# substitute <glyphclass> by <glyphclass>;  # format C
#
# E.g.:
#
# substitute a by A.sc;
#
# # Multiple
#
# substitute <glyph> by <glyph sequence>;
#
# E.g.:
#
# substitute f_f_i by f f i;
# sub ka by ka.pas_cakra ka;
#
# # Alternate
#
# substitute <glyph> from <glyphclass>;
#
# E.g.:
#
# substitute ampersand from [ampersand.1 ampersand.2 ampersand.3];
#
# # Ligature
#
# substitute <glyph sequence> by <glyph>;
#
# E.g.:
#
# sub f i by f_i;
# sub f f i by f_f_i;
# sub ka ka.pas_cakra.ns by ka;
#
# The order does not matter, the rendering engine sorts from longest to
# shortest.
#
# # Context
#
# E.g.:
#
# substitute a b c' d' e f by x y
# substitute c' by x y
#
# The rule has three parts: backtrack (a b), input (c' d'),
# and lookahead (e f) glyph sequences. The input is required,
# backtrack/lookahead is optional.
#
# The order matters, the first takes priority.
#
#
# # Chaining Context
#
# E.g.:
#
# sub ka' lookup REMOVE_CAKRA lookup REORDER_CAKRA ka.pas_cakra.ns' ;
# substitute [ a e i o u] f' lookup CNTXT_LIGS i' n' lookup CNTXT_SUB;
#
# The order matters, the first takes priority.
#
# The lookup can only be called for "input" part, and the lookup substitution
# is applied for each position (so CNTXT_LIGS for f' and CNTXT_SUB for n').
#
# Within each lookup, either exactly one rule will apply (and the new sequence
# is passed to the next lookup) or no rule will apply (and the original
# sequence is passed).
#
# The rule is first matched, for example `ka' ka.pas_cakra.ns'` or
# `[ a e i o u] f' i' n'`, and if it matches, then the lookup subsitutions are
# performed in order from left to right at the given position.
#
# Worked out example:
#
# lookup CNTXT_LIGS {
#     substitute f i by f_i;
#     substitute c t by c_t;
# } CNTXT_LIGS;
#
# lookup CNTXT_SUB {
#     substitute n by n.end;
#     substitute s by s.end;
# } CNTXT_SUB;
#
# feature test {
#     substitute [ a e i o u] f' lookup CNTXT_LIGS i' n' lookup CNTXT_SUB;
#     substitute [ a e i o u] c' lookup CNTXT_LIGS t' s' lookup CNTXT_SUB;
# } test;
#
# Here are the steps:
#
# a f i n -> a f_i n -> a f_i n.end
# e c t s -> a c_t s -> a c_t s.end
# e c t n -> e c t n                   # no match
#
#

languagesystem DFLT dflt;
languagesystem latn dflt;

# Basic letters from unicode input (no connections, no begin/end)
@LETTER_LC = [a-z
    aacute adieresis ccaron dcaron eacute ecaron iacute lacute lcaron ncaron
    oacute ocircumflex racute rcaron scaron tcaron uacute uring yacute zcaron];

@LETTER_UC = [A-Z
    Aacute Adieresis Ccaron Dcaron Eacute Ecaron Iacute Lacute Lcaron Ncaron
    Oacute Ocircumflex Racute Rcaron Scaron Tcaron Uacute Uring Yacute Zcaron];

@LETTER0 = [@LETTER_LC @LETTER_UC];

# Our custom versions of letters, cannot be input directly
@LETTER1 = [sleft sdepth scaronleft scarondepth bnarrow onarrow oacutenarrow ocircumflexnarrow vnarrow wnarrow];

# All inner word connections (no begin/end), cannot be input directly
@CONN = [conn_s conn_sv conn_P];

# All letters including connecting paths (conn_s, conn_sv, ...), but no begin
# and end glyphs
@LETTER = [@LETTER0 @LETTER1 @CONN];

@BCONN_LETTERS = [m n ncaron v w y yacute];
@SCONN_LETTERS = [@BCONN_LETTERS t tcaron z zcaron];


lookup LETTER_BEGIN {
# beginning of the word
    ignore substitute @LETTER b';
    substitute b' by begin b;
    ignore substitute @LETTER e';
    substitute e' by begin e;
    ignore substitute @LETTER eacute';
    substitute eacute' by begin eacute;
    ignore substitute @LETTER ecaron';
    substitute ecaron' by begin ecaron;
    ignore substitute @LETTER f';
    substitute f' by begin f;
    ignore substitute @LETTER h';
    substitute h' by begin h;
    ignore substitute @LETTER i';
    substitute i' by begin i;
    ignore substitute @LETTER iacute';
    substitute iacute' by begin iacute;
    ignore substitute @LETTER j';
    substitute j' by begin j;
    ignore substitute @LETTER k';
    substitute k' by begin k;
    ignore substitute @LETTER l';
    substitute l' by begin l;
    ignore substitute @LETTER lacute';
    substitute lacute' by begin lacute;
    ignore substitute @LETTER lcaron';
    substitute lcaron' by begin lcaron;
    ignore substitute @LETTER m';
    substitute m' by begin_straight m;
    ignore substitute @LETTER n';
    substitute n' by begin_straight n;
    ignore substitute @LETTER ncaron';
    substitute ncaron' by begin_straight ncaron;
    ignore substitute @LETTER p';
    substitute p' by begin p;
    ignore substitute @LETTER r';
    substitute r' by begin r;
    ignore substitute @LETTER rcaron';
    substitute rcaron' by begin rcaron;
    ignore substitute @LETTER racute';
    substitute racute' by begin racute;
    ignore substitute @LETTER s';
    substitute s' by begin s;
    ignore substitute @LETTER scaron';
    substitute scaron' by begin scaron;
    ignore substitute @LETTER t';
    substitute t' by begin t;
    ignore substitute @LETTER tcaron';
    substitute tcaron' by begin tcaron;
    ignore substitute @LETTER u';
    substitute u' by begin u;
    ignore substitute @LETTER uacute';
    substitute uacute' by begin uacute;
    ignore substitute @LETTER uring';
    substitute uring' by begin uring;
    ignore substitute @LETTER v';
    substitute v' by begin_straight v;
    ignore substitute @LETTER w';
    substitute w' by begin_straight w;
    ignore substitute @LETTER x';
    substitute x' by begin_x x;
    ignore substitute @LETTER y';
    substitute y' by begin_straight y;
    ignore substitute @LETTER yacute';
    substitute yacute' by begin_straight yacute;
    ignore substitute @LETTER z';
    substitute z' by begin_straight z;
    ignore substitute @LETTER zcaron';
    substitute zcaron' by begin_straight zcaron;
} LETTER_BEGIN;

lookup LETTER_END {
# end of the word
    ignore substitute a' @LETTER;
    substitute a' by a end;
} LETTER_END;

feature liga {
  #substitute @LETTER0' lookup LETTER_END lookup LETTER_BEGIN;
  substitute a' lookup LETTER_END;
} liga;
